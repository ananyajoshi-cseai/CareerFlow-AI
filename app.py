import streamlit as st
import google.generativeai as genai
import pdfplumber
import json
import sqlite3
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import requests
from fpdf import FPDF
from bs4 import BeautifulSoup
from streamlit_lottie import st_lottie
from streamlit_option_menu import option_menu

# --- PAGE CONFIG ---
st.set_page_config(page_title="CareerFlow AI", layout="wide", page_icon="üß†")

# --- STATE INITIALIZATION ---
if 'user_skills' not in st.session_state: st.session_state.user_skills = {}
if 'market_skills' not in st.session_state: st.session_state.market_skills = {}
if 'missing' not in st.session_state: st.session_state.missing = set()
if 'match' not in st.session_state: st.session_state.match = set()
if 'resume_text' not in st.session_state: st.session_state.resume_text = ""
if 'jd_text' not in st.session_state: st.session_state.jd_text = ""
if 'role_title' not in st.session_state: st.session_state.role_title = ""
if 'company_name' not in st.session_state: st.session_state.company_name = ""
if 'api_key' not in st.session_state: st.session_state.api_key = ""
if 'cover_letter' not in st.session_state: st.session_state.cover_letter = ""

# --- CUSTOM CSS ---
st.markdown("""
<style>
    .stApp { background-color: #0E1117; font-family: 'Poppins', sans-serif; }
    [data-testid="stHeader"] { background-color: transparent !important; z-index: 100; }
    h1, h2, h3, h4, h5, h6, p, span, div, label { color: #FAFAFA !important; }
    .stTextInput input, .stTextArea textarea { background-color: #1F2937 !important; color: white !important; border: 1px solid #374151 !important; }
    .glass-card { background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 25px; margin-bottom: 25px; }
    div.stButton > button { background: linear-gradient(90deg, #00C9FF 0%, #92FE9D 100%) !important; color: black !important; font-weight: bold !important; border: none; border-radius: 50px; padding: 10px 25px; }
    div.stButton > button:hover { transform: scale(1.05); }
</style>
""", unsafe_allow_html=True)

# --- AI ENGINE ---
def get_gemini_response(prompt):
    if not st.session_state.api_key: return None
    genai.configure(api_key=st.session_state.api_key.strip())
    try:
        valid_models = [m.name for m in genai.list_models() if 'generateContent' in m.supported_generation_methods]
        if not valid_models: return "Error: No AI models found."
        selected_model = valid_models[0]
        for m in valid_models:
            if "flash" in m: selected_model = m; break
        model = genai.GenerativeModel(selected_model)
        response = model.generate_content(prompt)
        return response.text
    except Exception as e: return f"Error: {str(e)}"

def ai_extract_skills(text):
    if not text: return {}
    prompt = f"""
    You are an expert Resume Parser. 
    Extract technical skills, hard skills, and soft skills from the following text.
    Categorize them strictly into these keys: 'Languages', 'Frameworks', 'Tools', 'Cloud', 'Soft Skills', 'Other'.
    Return ONLY a valid JSON object. Do not add markdown formatting.
    Text: {text[:4000]}
    """
    response = get_gemini_response(prompt)
    if response and not response.startswith("Error"):
        try: return json.loads(response.replace("```json", "").replace("```", "").strip())
        except: return {}
    return {}

def ai_generate_questions(missing_skills, role):
    skills_str = ", ".join(list(missing_skills)[:5])
    prompt = f"I am applying for {role} but missing: {skills_str}. Generate 3 tough interview questions testing these specific gaps."
    return get_gemini_response(prompt)

def ai_write_cover_letter(resume, jd, role, company):
    prompt = f"Write a professional cover letter for {role} at {company}. Resume Summary: {resume[:2000]}. JD: {jd[:2000]}. Keep it under 300 words."
    return get_gemini_response(prompt)

def ai_resume_critique(resume, role):
    prompt = f"""
    Act as a Senior Technical Recruiter. Critique this resume for a {role} position.
    Provide output in 3 distinct sections using Markdown:
    1. ‚úÖ **What You Did Well**
    2. ‚ö†Ô∏è **Areas for Improvement**
    3. üí° **Actionable Advice**
    Resume Text: {resume[:3000]}
    """
    return get_gemini_response(prompt)

# --- CHARTING & PDF ---
class PDF(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 12)
        self.cell(0, 10, 'Generated by CareerFlow AI', 0, 1, 'C')
        self.ln(10)

def create_pdf(text):
    pdf = PDF()
    pdf.add_page()
    pdf.set_font("Arial", size=11)
    clean_text = text.encode('latin-1', 'replace').decode('latin-1')
    pdf.multi_cell(0, 10, clean_text)
    return pdf.output(dest='S').encode('latin-1')

def create_radar_chart(json_data):
    # Convert JSON dict to DataFrame for Plotly
    data = {"Category": [], "Count": []}
    for category, skills in json_data.items():
        data["Category"].append(category)
        data["Count"].append(len(skills))
    
    df = pd.DataFrame(data)
    if df.empty: return None
    
    fig = px.line_polar(df, r='Count', theta='Category', line_close=True)
    fig.update_traces(fill='toself', line_color='#92FE9D')
    fig.update_layout(
        polar=dict(
            bgcolor="rgba(0,0,0,0)",
            radialaxis=dict(visible=True, showticklabels=False),
            angularaxis=dict(color="white")
        ),
        paper_bgcolor="rgba(0,0,0,0)",
        font=dict(color="white"),
        height=300,
        margin=dict(l=40, r=40, t=20, b=20)
    )
    return fig

# --- HELPERS ---
def load_lottieurl(url):
    try: return requests.get(url).json()
    except: return None
lottie_robot = load_lottieurl("https://assets5.lottiefiles.com/packages/lf20_koun56.json")

def extract_text_from_pdf(file):
    text = ""
    with pdfplumber.open(file) as pdf:
        for page in pdf.pages: text += page.extract_text() or ""
    return text

def scrape_jd_from_url(url):
    try:
        response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
        if response.status_code == 200:
            soup = BeautifulSoup(response.text, 'html.parser')
            for script in soup(["script", "style"]): script.extract()
            return soup.get_text()[:5000]
    except: return None

def save_to_db(role, company, skills_dict, score):
    conn = sqlite3.connect('career_data.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS jobs (id INTEGER PRIMARY KEY, role_title TEXT, company TEXT, match_score REAL, date_added TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
    c.execute('''CREATE TABLE IF NOT EXISTS required_skills (id INTEGER PRIMARY KEY, job_id INTEGER, skill_name TEXT, category TEXT, FOREIGN KEY (job_id) REFERENCES jobs (id))''')
    c.execute("INSERT INTO jobs (role_title, company, match_score) VALUES (?, ?, ?)", (role, company, score))
    job_id = c.lastrowid
    for cat, skills in skills_dict.items():
        for skill in skills:
            c.execute("INSERT INTO required_skills (job_id, skill_name, category) VALUES (?, ?, ?)", (job_id, skill, cat))
    conn.commit()
    conn.close()

# --- SIDEBAR (Updated for Deployment) ---
with st.sidebar:
    st.markdown("# üß† CareerFlow AI")
    
    # Check if key is in Secrets first
    if "GEMINI_API_KEY" in st.secrets:
        st.session_state.api_key = st.secrets["GEMINI_API_KEY"]
        st.success("‚úÖ AI Connected via Secrets")
    else:
        st.session_state.api_key = st.text_input("Gemini API Key", type="password")
        if st.session_state.api_key: st.success("‚úÖ AI Connected")
    
    # THIS LINE MUST BE HERE - BEFORE the if/elif blocks
    selected = option_menu(
        menu_title=None,
        options=["Scanner", "Battle Mode", "Analytics", "Tools"],
        icons=["search", "trophy", "bar-chart-line", "tools"], 
        default_index=0,
        styles={"nav-link-selected": {"background-color": "#00C9FF", "color": "black"}}
    )

# === PAGE 1: SCANNER ===
if selected == "Scanner":
    # ... rest of your scanner code ...
    col1, col2 = st.columns([1.5, 1])
    with col1: st.markdown('<h1 style="color:#00C9FF;">AI Skill Gap Analyzer</h1>', unsafe_allow_html=True)
    with col2: 
        if lottie_robot: st_lottie(lottie_robot, height=150, key="robot")

    with st.container(border=True):
        c1, c2 = st.columns(2)
        with c1:
            st.markdown("### üìÑ Your Profile")
            uploaded_file = st.file_uploader("Upload Resume (PDF)", type="pdf")
            if uploaded_file:
                text = extract_text_from_pdf(uploaded_file)
                st.session_state.resume_text = text
                if st.button("üß† Analyze Resume with AI"):
                    if not st.session_state.api_key: st.error("Need API Key")
                    else:
                        with st.spinner("Analyzing..."):
                            data = ai_extract_skills(text)
                            if data:
                                st.session_state.user_skills = data
                                st.success(f"Extracted {sum(len(v) for v in data.values())} skills")

        with c2:
            st.markdown("### üéØ Target Role")
            st.session_state.role_title = st.text_input("Job Title", value=st.session_state.role_title)
            st.session_state.company_name = st.text_input("Company", value=st.session_state.company_name)
            
            jd_tabs = st.tabs(["Paste JD", "Link"])
            with jd_tabs[0]: jd_input = st.text_area("Job Description", height=150)
            with jd_tabs[1]:
                url = st.text_input("URL")
                if st.button("Scrape"):
                    scraped = scrape_jd_from_url(url)
                    if scraped: jd_input = scraped; st.success("Scraped!")
            if jd_input: st.session_state.jd_text = jd_input
            
            if st.button("üß† Analyze JD with AI"):
                if not st.session_state.api_key: st.error("Need API Key")
                elif not st.session_state.jd_text: st.error("No JD found")
                else:
                    with st.spinner("Analyzing..."):
                        data = ai_extract_skills(st.session_state.jd_text)
                        if data:
                            st.session_state.market_skills = data
                            st.success("JD Analyzed!")

    if st.button("üöÄ Calculate Match Score"):
        if st.session_state.user_skills and st.session_state.market_skills:
            # 1. MATCH LOGIC
            user_flat = set([s.lower() for sublist in st.session_state.user_skills.values() for s in sublist])
            market_flat = set([s.lower() for sublist in st.session_state.market_skills.values() for s in sublist])
            match = user_flat.intersection(market_flat)
            missing = market_flat - user_flat
            score = len(match) / len(market_flat) * 100 if market_flat else 0
            st.session_state.match = match
            st.session_state.missing = missing
            save_to_db(st.session_state.role_title, st.session_state.company_name, st.session_state.market_skills, score)
            
            # 2. VISUALS (GAUGE + RADAR)
            st.markdown("---")
            res_col1, res_col2 = st.columns(2)
            
            with res_col1:
                st.markdown("### Match Score")
                fig = go.Figure(go.Indicator(
                    mode = "gauge+number", value = score,
                    gauge = {'axis': {'range': [0, 100]}, 'bar': {'color': "#00C9FF"}}
                ))
                fig.update_layout(height=300, paper_bgcolor="rgba(0,0,0,0)", font={'color': "white"})
                st.plotly_chart(fig, use_container_width=True)
                st.markdown(f"**Missing:** {', '.join(missing)}")
            
            with res_col2:
                st.markdown("### üï∏Ô∏è Skill Distribution")
                radar_fig = create_radar_chart(st.session_state.user_skills)
                if radar_fig:
                    st.plotly_chart(radar_fig, use_container_width=True)
                else:
                    st.info("Not enough data for radar chart.")

# === PAGE 2: BATTLE MODE (VISUAL EDITION) ===
elif selected == "Battle Mode":
    st.markdown('<h1 style="color:#00C9FF; text-align: center;">‚öîÔ∏è Job Battle Arena ‚öîÔ∏è</h1>', unsafe_allow_html=True)
    st.markdown("<p style='text-align: center;'>AI-Powered Face-off: Which job wins?</p>", unsafe_allow_html=True)

    with st.container(border=True):
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("### ü•ä Challenger A")
            role_a = st.text_input("Role A", placeholder="Frontend Dev")
            company_a = st.text_input("Company A", placeholder="Google")
            jd_a = st.text_area("Paste JD A", height=150, key="jd_a")
        with col2:
            st.markdown("### ü•ä Challenger B")
            role_b = st.text_input("Role B", placeholder="Backend Dev")
            company_b = st.text_input("Company B", placeholder="Startup")
            jd_b = st.text_area("Paste JD B", height=150, key="jd_b")

    if st.button("üî• Fight! (Compare Jobs)"):
        if not st.session_state.api_key:
            st.error("‚ö†Ô∏è Enter API Key first!")
        elif not jd_a or not jd_b:
            st.warning("‚ö†Ô∏è Please paste both JDs.")
        else:
            with st.spinner("‚öîÔ∏è Judging the duel..."):
                # 1. THE PROMPT
                prompt = f"""
                Compare these two jobs for a candidate with this resume summary: "{st.session_state.resume_text[:500]}..."
                
                Job A: {role_a} at {company_a}
                JD A: {jd_a[:1500]}
                
                Job B: {role_b} at {company_b}
                JD B: {jd_b[:1500]}
                
                Return a valid JSON object with EXACTLY this structure:
                {{
                    "scores": {{
                        "Job A": {{ "Salary Potential": 80, "Work-Life Balance": 70, "Learning Curve": 90, "Resume Match": 75 }},
                        "Job B": {{ "Salary Potential": 90, "Work-Life Balance": 60, "Learning Curve": 85, "Resume Match": 60 }}
                    }},
                    "verdict": "Brief text explaining who wins and why."
                }}
                """
                
                response_text = get_gemini_response(prompt)
                
                # 2. PARSE JSON & VISUALIZE
                try:
                    # Clean up json string if AI adds markdown
                    clean_json = response_text.replace("```json", "").replace("```", "").strip()
                    data = json.loads(clean_json)
                    
                    # A. THE VERDICT
                    st.success(f"üèÜ Verdict: {data['verdict']}")
                    
                    # B. RADAR CHART (SPYDER WEB)
                    st.markdown("### üï∏Ô∏è Skill & Benefit Face-off")
                    
                    categories = list(data['scores']['Job A'].keys())
                    values_a = list(data['scores']['Job A'].values())
                    values_b = list(data['scores']['Job B'].values())
                    
                    fig = go.Figure()
                    
                    # Plot Job A
                    fig.add_trace(go.Scatterpolar(
                        r=values_a, theta=categories, fill='toself', name=f"{company_a} (A)",
                        line_color='#00C9FF'
                    ))
                    # Plot Job B
                    fig.add_trace(go.Scatterpolar(
                        r=values_b, theta=categories, fill='toself', name=f"{company_b} (B)",
                        line_color='#FF5733'
                    ))
                    
                    fig.update_layout(
                        polar=dict(
                            radialaxis=dict(visible=True, range=[0, 100]),
                            bgcolor="rgba(255, 255, 255, 0.05)"
                        ),
                        paper_bgcolor="rgba(0,0,0,0)",
                        font=dict(color="white"),
                        margin=dict(t=30, b=30)
                    )
                    st.plotly_chart(fig, use_container_width=True)
                    
                    # C. DONUT CHARTS (TOTAL SCORE)
                    st.markdown("### üç© Overall Match Score")
                    avg_a = sum(values_a) / len(values_a)
                    avg_b = sum(values_b) / len(values_b)
                    
                    d_col1, d_col2 = st.columns(2)
                    with d_col1:
                        st.markdown(f"<h3 style='text-align:center'>{company_a}</h3>", unsafe_allow_html=True)
                        fig_a = go.Figure(go.Pie(
                            values=[avg_a, 100-avg_a], 
                            labels=["Match", "Gap"], 
                            hole=.7,
                            marker_colors=['#00C9FF', '#1F2937'],
                            textinfo='none'
                        ))
                        fig_a.update_layout(showlegend=False, height=200, margin=dict(t=0, b=0, l=0, r=0), paper_bgcolor="rgba(0,0,0,0)")
                        # Add text in center
                        fig_a.add_annotation(text=f"{int(avg_a)}%", x=0.5, y=0.5, font_size=25, showarrow=False, font_color="white")
                        st.plotly_chart(fig_a, use_container_width=True)
                        
                    with d_col2:
                        st.markdown(f"<h3 style='text-align:center'>{company_b}</h3>", unsafe_allow_html=True)
                        fig_b = go.Figure(go.Pie(
                            values=[avg_b, 100-avg_b], 
                            labels=["Match", "Gap"], 
                            hole=.7,
                            marker_colors=['#FF5733', '#1F2937'],
                            textinfo='none'
                        ))
                        fig_b.update_layout(showlegend=False, height=200, margin=dict(t=0, b=0, l=0, r=0), paper_bgcolor="rgba(0,0,0,0)")
                        fig_b.add_annotation(text=f"{int(avg_b)}%", x=0.5, y=0.5, font_size=25, showarrow=False, font_color="white")
                        st.plotly_chart(fig_b, use_container_width=True)

                except json.JSONDecodeError:
                    st.error("‚ö†Ô∏è AI Analysis failed to format correctly. Here is the raw text:")
                    st.write(response_text)
# === PAGE 3: ANALYTICS ===
elif selected == "Analytics":
    st.title("üìä Market Intelligence")
    conn = sqlite3.connect('career_data.db')
    an_tab1, an_tab2 = st.tabs(["üìà Dashboard", "üóÇÔ∏è Manage Data"])
    
    with an_tab1:
        try:
            total = pd.read_sql("SELECT COUNT(*) as count FROM jobs", conn).iloc[0]['count']
            avg = pd.read_sql("SELECT AVG(match_score) as score FROM jobs", conn).iloc[0]['score']
            avg = round(avg, 1) if avg else 0
        except: total, avg = 0, 0
        
        c1, c2 = st.columns(2)
        with c1: st.markdown(f"<div class='glass-card' style='text-align:center'><h3>Jobs Scanned</h3><h1 style='color:#00C9FF; font-size:40px'>{total}</h1></div>", unsafe_allow_html=True)
        with c2: st.markdown(f"<div class='glass-card' style='text-align:center'><h3>Avg Match Score</h3><h1 style='color:#92FE9D; font-size:40px'>{avg}%</h1></div>", unsafe_allow_html=True)
        
        st.markdown("### üö® Top Missing Skills")
        try:
            df = pd.read_sql("SELECT skill_name, COUNT(*) as f FROM required_skills GROUP BY skill_name ORDER BY f DESC LIMIT 10", conn)
            if not df.empty:
                fig = px.bar(df, x='f', y='skill_name', orientation='h', title="Most Demanded Skills", color='f')
                fig.update_layout(paper_bgcolor="rgba(0,0,0,0)", font={'color': "white"})
                st.plotly_chart(fig, use_container_width=True)
        except: st.info("No data yet.")

    with an_tab2:
        st.markdown("### üóëÔ∏è Manage Database")
        try:
            df_all = pd.read_sql("SELECT id, role_title, company, match_score, date_added FROM jobs ORDER BY date_added DESC", conn)
            if not df_all.empty:
                st.dataframe(df_all, use_container_width=True, hide_index=True)
                job_options = df_all.apply(lambda x: f"ID: {x['id']} | {x['role_title']} at {x['company']}", axis=1)
                sel = st.selectbox("Select Job to Delete", options=job_options)
                if st.button("‚ùå Delete"):
                    jid = int(sel.split("|")[0].replace("ID:", "").strip())
                    conn.execute("DELETE FROM required_skills WHERE job_id = ?", (jid,))
                    conn.execute("DELETE FROM jobs WHERE id = ?", (jid,))
                    conn.commit()
                    st.toast("Deleted!", icon="üóëÔ∏è")
                    st.rerun()
            else: st.info("Database is empty.")
        except: st.error("DB Error")
    conn.close()

# === PAGE 4: TOOLS ===
elif selected == "Tools":
    st.title("üõ†Ô∏è AI Career Tools")
    if not st.session_state.resume_text: st.warning("‚ö†Ô∏è Upload resume in 'Scanner' first!")
    else:
        t1, t2, t3 = st.tabs(["üìù Cover Letter", "üîé Resume Critique", "ü§ñ Interview Prep"])
        with t1:
            if st.button("Generate Cover Letter"):
                with st.spinner("Writing..."):
                    st.session_state.cover_letter = ai_write_cover_letter(st.session_state.resume_text, st.session_state.jd_text, st.session_state.role_title, st.session_state.company_name)
            if st.session_state.cover_letter:
                st.write(st.session_state.cover_letter)
                pdf_bytes = create_pdf(st.session_state.cover_letter)
                st.download_button("üìÑ Download PDF", data=pdf_bytes, file_name="cover_letter.pdf", mime="application/pdf")
        with t2:
            st.markdown("### üîé AI Resume Auditor")
            if st.button("Analyze Weaknesses"):
                with st.spinner("Auditing..."):
                    st.markdown(ai_resume_critique(st.session_state.resume_text, st.session_state.role_title))
        with t3:
            if st.button("Generate Questions"):
                if st.session_state.missing: st.markdown(ai_generate_questions(st.session_state.missing, st.session_state.role_title))

                else: st.info("No missing skills to test!")

